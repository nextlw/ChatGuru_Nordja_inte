 /// Worker Handler: Processa mensagens do Pub/Sub
///
/// Arquitetura:
/// 1. Recebe payload RAW do Pub/Sub via HTTP POST
/// 2. Processa com OpenAI para classifica√ß√£o
/// 3. Se for atividade, cria tarefa no ClickUp
/// 4. Envia anota√ß√£o de volta ao ChatGuru
///
/// Este endpoint √© chamado automaticamente pelo Cloud Tasks
/// Headers esperados:
/// - X-CloudTasks-TaskName: Nome da task
/// - X-CloudTasks-QueueName: Nome da fila
/// - X-CloudTasks-TaskRetryCount: N√∫mero de tentativas (0-indexed)

use axum::{
    extract::{Request, State},
    response::Json,
    body::Body,
    http::StatusCode,
};
use serde_json::{json, Value};
use std::sync::Arc;
use tokio::time::Instant;
use base64::{Engine as _, engine::general_purpose};

use chatguru_clickup_middleware::models::payload::WebhookPayload;
use chatguru::ChatGuruClient;
use chatguru_clickup_middleware::utils::{AppResult, AppError};
use chatguru_clickup_middleware::utils::logging::*;
use chatguru_clickup_middleware::AppState;
// Usar services do crate clickup ao inv√©s de duplicar no main project
use clickup::folders::SmartFolderFinder;
use clickup::assignees::SmartAssigneeFinder;
use clickup::fields::CustomFieldManager;

// Configura√ß√£o de retry
const MAX_RETRY_ATTEMPTS: u32 = 3;

/// Handler do worker
/// Retorna 200 OK se processado com sucesso
/// Retorna 4xx se erro n√£o recuper√°vel (n√£o faz retry)
/// Retorna 5xx se erro recuper√°vel (Pub/Sub faz retry at√© MAX_RETRY_ATTEMPTS)
pub async fn handle_worker(
    State(state): State<Arc<AppState>>,
    request: Request<Body>,
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    // CORRE√á√ÉO CR√çTICA: Valida√ß√£o preventiva antes de processar
    // Verificar headers b√°sicos para detectar problemas early
    let content_type = request.headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("");
        
    let content_length = request.headers()
        .get("content-length")
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(0);
    
    // Log de diagn√≥stico para headers cr√≠ticos
    log_info(&format!(
        "üîç WORKER REQUEST HEADERS - Content-Type: '{}' | Content-Length: {} | Headers: {}",
        content_type,
        content_length,
        request.headers().len()
    ));
    
    // Valida√ß√£o preventiva de content-type (Pub/Sub deve ser application/json)
    if !content_type.is_empty() && !content_type.contains("application/json") {
        log_error(&format!("‚ùå INVALID CONTENT-TYPE - Expected JSON, got: '{}'", content_type));
        return Err((
            StatusCode::BAD_REQUEST,
            Json(json!({
                "error": "Invalid Content-Type, expected application/json",
                "received_content_type": content_type,
                "status": "invalid_request"
            }))
        ));
    }
    
    // Valida√ß√£o preventiva de tamanho (m√°x 50MB para Pub/Sub)
    if content_length > 50_000_000 {
        log_error(&format!("‚ùå PAYLOAD TOO LARGE - Size: {} bytes (max: 50MB)", content_length));
        return Err((
            StatusCode::PAYLOAD_TOO_LARGE,
            Json(json!({
                "error": "Payload too large",
                "size_bytes": content_length,
                "max_size_bytes": 50_000_000,
                "status": "payload_too_large"
            }))
        ));
    }
    
    // Timeout global reduzido para detectar problemas mais rapidamente
    let global_timeout = std::time::Duration::from_secs(45);
    
    match tokio::time::timeout(global_timeout, handle_worker_internal(state, request)).await {
        Ok(result) => result,
        Err(_) => {
            log_error("‚ùå TIMEOUT GLOBAL - Worker excedeu 45 segundos, for√ßando t√©rmino");
            Err((
                StatusCode::GATEWAY_TIMEOUT,
                Json(json!({
                    "error": "Worker timeout - processing exceeded 45 seconds",
                    "status": "timeout",
                    "timeout_seconds": 45
                }))
            ))
        }
    }
}

/// Implementa√ß√£o interna do worker com timeouts detalhados
async fn handle_worker_internal(
    state: Arc<AppState>,
    request: Request<Body>,
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    let start_time = Instant::now();
    
    // Log de in√≠cio com informa√ß√µes de request
    log_info(&format!(
        "üöÄ WORKER INICIADO - Start time: {:?} | Headers count: {}",
        start_time,
        request.headers().len()
    ));
    
    log_request_received("/worker/process", "POST");

    // Primeiro, extrair headers antes de consumir o request
    let retry_count = request
        .headers()
        .get("googclient_deliveryattempt")
        .or_else(|| request.headers().get("x-goog-delivery-attempt"))
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.parse::<u32>().ok())
        .unwrap_or(1); // Pub/Sub starts at 1, not 0

    let message_id = request
        .headers()
        .get("x-cloudtasks-taskname")
        .or_else(|| request.headers().get("x-pubsub-messageid"))
        .and_then(|v| v.to_str().ok())
        .unwrap_or("-")
        .to_string();

    log_info(&format!("üîÑ Tentativa {} de {} (header: googclient_deliveryattempt), messageId: {}", retry_count, MAX_RETRY_ATTEMPTS, message_id));

    // Se excedeu o limite, retornar 200 para evitar loop infinito
    if retry_count > MAX_RETRY_ATTEMPTS {
        log_error(&format!("‚ùå Limite de tentativas excedido ({}/{}), descartando mensagem",
            retry_count, MAX_RETRY_ATTEMPTS));
        return Ok(Json(json!({
            "status": "discarded",
            "reason": "Max retry attempts exceeded",
            "retry_count": retry_count
        })));
    }

    // CORRE√á√ÉO CR√çTICA: Timeout muito baixo para detectar problemas rapidamente
    let body_limit = 50_000_000; // 50MB m√°ximo (Pub/Sub pode ser grande)
    let body_timeout = std::time::Duration::from_secs(5); // Reduzido de 10s para 5s
    
    log_info(&format!("üì¶ Reading body with timeout: {}s, limit: {}MB",
        body_timeout.as_secs(), body_limit / 1_000_000));
    
    let body_bytes = match tokio::time::timeout(
        body_timeout,
        axum::body::to_bytes(request.into_body(), body_limit)
    ).await {
        Ok(Ok(bytes)) => {
            log_info(&format!("‚úÖ Body read successfully: {} bytes", bytes.len()));
            bytes
        },
        Ok(Err(e)) => {
            log_error(&format!("‚ùå BODY READ ERROR - {}", e));
            return Err((
                StatusCode::PAYLOAD_TOO_LARGE,
                Json(json!({
                    "error": "Request body too large or invalid",
                    "limit_mb": body_limit / 1_000_000,
                    "details": e.to_string(),
                    "status": "body_read_error"
                }))
            ));
        },
        Err(_) => {
            log_error(&format!("‚ùå BODY TIMEOUT - Failed to read body within {}s", body_timeout.as_secs()));
            return Err((
                StatusCode::REQUEST_TIMEOUT,
                Json(json!({
                    "error": "Timeout reading request body",
                    "timeout_seconds": body_timeout.as_secs(),
                    "status": "body_timeout"
                }))
            ));
        }
    };

    // Validar se o body n√£o est√° vazio
    if body_bytes.is_empty() {
        log_error("Request body is empty");
        return Err((
            StatusCode::BAD_REQUEST,
            Json(json!({"error": "Empty request body"}))
        ));
    }

    let body_str = match String::from_utf8(body_bytes.to_vec()) {
        Ok(s) => s,
        Err(e) => {
            log_error(&format!("Invalid UTF-8: {}", e));
            return Err((
                StatusCode::BAD_REQUEST,
                Json(json!({"error": "Invalid UTF-8"}))
            ));
        }
    };

    // CORRE√á√ÉO: Parsing JSON mais robusto
    let envelope: Value = match serde_json::from_str::<Value>(&body_str) {
        Ok(v) => {
            log_info(&format!("‚úÖ JSON parsed successfully: {} fields",
                v.as_object().map_or(0, |o| o.len())));
            v
        },
        Err(e) => {
            log_error(&format!("‚ùå JSON PARSE ERROR - {} | Body preview: {}",
                e,
                if body_str.len() > 200 {
                    format!("{}...", &body_str[..200])
                } else {
                    body_str.clone()
                }
            ));
            return Err((
                StatusCode::BAD_REQUEST,
                Json(json!({
                    "error": "Invalid JSON format",
                    "details": e.to_string(),
                    "status": "json_parse_error",
                    "body_preview": if body_str.len() > 200 {
                        format!("{}...", &body_str[..200])
                    } else {
                        body_str
                    }
                }))
            ));
        }
    };

    // Extrair e decodificar payload do Pub/Sub
    // Formato completo do payload vindo do ChatGuru (via Pub/Sub):
    // {
    //   "message": {
    //     "data": "base64_encoded_json",
    //     "messageId": "12345678",
    //     "publishTime": "2025-01-01T00:00:00.000Z"
    //   },
    //   "subscription": "projects/PROJECT_ID/subscriptions/SUBSCRIPTION_NAME"
    // }
    //
    // Onde "data" (decodificado) cont√©m envelope interno:
    // {
    //   "raw_payload": "{\"id_chatguru\":\"...\",\"texto_mensagem\":\"...\",\"celular\":\"...\",\"nome\":\"...\",\"media_url\":\"...\",\"media_type\":\"...\",...}"
    // }
    //
    // E raw_payload (decodificado) cont√©m o payload real do ChatGuru:
    // {
    //   "campanha_id": "123",
    //   "campanha_nome": "WhatsApp",
    //   "origem": "whatsapp",
    //   "email": "cliente@example.com",
    //   "nome": "Jo√£o Silva",
    //   "tags": ["tag1", "tag2"],
    //   "texto_mensagem": "Preciso de um motoboy",
    //   "media_url": "https://...",
    //   "media_type": "audio/ogg",
    //   "campos_personalizados": {},
    //   "bot_context": { "ChatGuru": true },
    //   "responsavel_nome": "Atendente",
    //   "responsavel_email": "atendente@example.com",
    //   "link_chat": "https://...",
    //   "celular": "5511999999999",
    //   "phone_id": "phone123",
    //   "chat_id": "chat123",
    //   "chat_created": "2025-01-01T00:00:00Z"
    // }
    let raw_payload_str = if let Some(message) = envelope.get("message") {
        // Formato padr√£o do Pub/Sub Push
        if let Some(data_b64) = message.get("data").and_then(|v| v.as_str()) {
            // Decodificar base64
            match general_purpose::STANDARD.decode(data_b64) {
                Ok(decoded_bytes) => {
                    match String::from_utf8(decoded_bytes) {
                        Ok(s) => s,
                        Err(e) => {
                            log_error(&format!("Invalid UTF-8 in Pub/Sub data: {}", e));
                            return Err((
                                StatusCode::BAD_REQUEST,
                                Json(json!({"error": "Invalid UTF-8 in message data"}))
                            ));
                        }
                    }
                },
                Err(e) => {
                    log_error(&format!("Failed to decode base64: {}", e));
                    return Err((
                        StatusCode::BAD_REQUEST,
                        Json(json!({"error": "Invalid base64 encoding"}))
                    ));
                }
            }
        } else {
            log_error("Missing 'data' field in Pub/Sub message");
            return Err((
                StatusCode::BAD_REQUEST,
                Json(json!({"error": "Missing data in message"}))
            ));
        }
    } else if let Some(raw_payload) = envelope.get("raw_payload").and_then(|v| v.as_str()) {
        // Formato direto (para testes)
        raw_payload.to_string()
    } else {
        log_error("Missing 'message' or 'raw_payload' in envelope");
        return Err((
            StatusCode::BAD_REQUEST,
            Json(json!({"error": "Invalid envelope format"}))
        ));
    };

    // Parsear o envelope que cont√©m o raw_payload
    // O formato esperado ap√≥s decodificar base64 √©:
    // { "raw_payload": "{...chatguru payload...}", "received_at": "...", "source": "...", ... }
    let inner_envelope: Value = match serde_json::from_str(&raw_payload_str) {
        Ok(v) => v,
        Err(e) => {
            log_error(&format!("Failed to parse envelope: {}", e));
            return Err((
                StatusCode::BAD_REQUEST,
                Json(json!({"error": "Invalid envelope format"}))
            ));
        }
    };

    // Extrair o raw_payload do envelope (ou usar o pr√≥prio envelope se n√£o tiver esse campo)
    let chatguru_payload_str = if let Some(raw_payload) = inner_envelope.get("raw_payload").and_then(|v| v.as_str()) {
        // Formato esperado: envelope tem campo raw_payload (string JSON)
        raw_payload.to_string()
    } else {
        // Fallback: o pr√≥prio envelope j√° √© o payload do ChatGuru (para compatibilidade)
        log_warning("‚ö†Ô∏è  Envelope sem campo 'raw_payload', usando envelope completo como payload");
        raw_payload_str.clone()
    };

    // Validar que o payload n√£o est√° vazio
    if chatguru_payload_str.trim().is_empty() {
        log_error("Payload do ChatGuru est√° vazio");
        return Err((
            StatusCode::BAD_REQUEST,
            Json(json!({"error": "Empty payload"}))
        ));
    }

    // Parsear payload do ChatGuru
    let mut payload: WebhookPayload = match serde_json::from_str(&chatguru_payload_str) {
        Ok(p) => p,
        Err(e) => {
            log_error(&format!("Failed to parse ChatGuru payload: {}", e));
            // Erro n√£o recuper√°vel - n√£o fazer retry
            return Err((
                StatusCode::BAD_REQUEST,
                Json(json!({"error": "Invalid ChatGuru payload"}))
            ));
        }
    };

    // Extrair informa√ß√µes b√°sicas para logging detalhado
    let sender_name = extract_nome_from_payload(&payload);
    let message_text = extract_message_from_payload(&payload);
    let phone = extract_phone_from_payload(&payload);
    let chat_id = extract_chat_id_from_payload(&payload);
    
    // Log detalhado do worker iniciando processamento
    log_info(&format!(
        "üîß WORKER INICIANDO PROCESSAMENTO - MessageID: {} | Tentativa: {}/{} | Sender: {} | Phone: {} | ChatID: {} | Size: {} chars",
        message_id,
        retry_count,
        MAX_RETRY_ATTEMPTS,
        sender_name,
        phone.as_deref().unwrap_or("N/A"),
        chat_id.as_deref().unwrap_or("N/A"),
        message_text.len()
    ));

    // Log do payload para debug (vers√£o resumida)
    log_info(&format!("üì¶ Payload processado com sucesso ({} bytes)",
        serde_json::to_string(&payload).unwrap_or_default().len()
    ));

    // Processar m√≠dia (√°udio/imagem) se houver
    if let WebhookPayload::ChatGuru(ref mut chatguru_payload) = payload {
        // IMPORTANTE: Normalizar campos de m√≠dia do ChatGuru
        // Converte tipo_mensagem + url_arquivo ‚Üí media_type + media_url
        chatguru_payload.normalize_media_fields();

        // Log dos campos de m√≠dia (ap√≥s normaliza√ß√£o)
        log_info(&format!("üîç Debug m√≠dia - media_url: {:?}, media_type: {:?}, tipo_mensagem: {:?}, url_arquivo: {:?}, texto_mensagem: {:?}",
            chatguru_payload.media_url,
            chatguru_payload.media_type,
            chatguru_payload.tipo_mensagem,
            chatguru_payload.url_arquivo,
            chatguru_payload.texto_mensagem
        ));

        // Verificar se tem media_url e media_type
        if let (Some(media_url), Some(media_type)) = (&chatguru_payload.media_url, &chatguru_payload.media_type) {
            // Verificar se √© tipo de m√≠dia suportado (√°udio, imagem, PDF)
            let is_supported = media_type.contains("audio") || media_type.contains("image") || media_type.contains("pdf");
            if is_supported {
                let processing_type = if media_type.contains("audio") {
                    "audio"
                } else if media_type.contains("image") {
                    "image"
                } else {
                    "pdf"
                };

                log_info(&format!("üìé M√≠dia detectada ({}: {}), iniciando processamento: {}",
                    processing_type, media_type, media_url));

                // Processar m√≠dia com anota√ß√£o usando IaService
                let (final_result, annotation_opt) = if let Some(ref ia_service) = state.ia_service {
                    match processing_type {
                        "audio" => {
                            log_info("üéµ Processando √°udio com transcri√ß√£o + anota√ß√£o");
                            // Timeout e limite de tamanho para √°udio (m√°x 5MB, 10s)
                            match tokio::time::timeout(
                                std::time::Duration::from_secs(10),
                                ia_service.download_file(media_url, "√Åudio")
                            ).await {
                                Ok(Ok(audio_bytes)) if audio_bytes.len() <= 5_000_000 => {
                                    let extension = media_url
                                        .split('.')
                                        .last()
                                        .and_then(|ext| ext.split('?').next())
                                        .unwrap_or("ogg");
                                    let filename = format!("audio.{}", extension);

                                    // Timeout para processamento de √°udio (m√°x 15s)
                                    match tokio::time::timeout(
                                        std::time::Duration::from_secs(15),
                                        ia_service.process_audio_with_annotation(&audio_bytes, &filename)
                                    ).await {
                                        Ok(Ok(result)) => {
                                            log_info(&format!("‚úÖ √Åudio processado: {} caracteres", result.extracted_content.len()));
                                            (Some(result.extracted_content), result.annotation)
                                        }
                                        Ok(Err(e)) => {
                                            log_error(&format!("‚ùå Erro ao processar √°udio: {}", e));
                                            (None, None)
                                        }
                                        Err(_) => {
                                            log_error("‚ùå Timeout ao processar √°udio (15s)");
                                            (None, None)
                                        }
                                    }
                                }
                                Ok(Ok(_)) => {
                                    log_error("‚ùå Arquivo de √°udio muito grande (>5MB), ignorando");
                                    (None, None)
                                }
                                Ok(Err(e)) => {
                                    log_error(&format!("‚ùå Erro ao baixar √°udio: {}", e));
                                    (None, None)
                                }
                                Err(_) => {
                                    log_error("‚ùå Timeout ao baixar √°udio (10s)");
                                    (None, None)
                                }
                            }
                        }
                        "image" => {
                            log_info("üñºÔ∏è Processando imagem com descri√ß√£o + anota√ß√£o");
                            // Timeout e limite para imagem (m√°x 3MB, 8s download, 10s processing)
                            match tokio::time::timeout(
                                std::time::Duration::from_secs(8),
                                ia_service.download_file(media_url, "Imagem")
                            ).await {
                                Ok(Ok(image_bytes)) if image_bytes.len() <= 3_000_000 => {
                                    match tokio::time::timeout(
                                        std::time::Duration::from_secs(10),
                                        ia_service.process_image_with_annotation(&image_bytes)
                                    ).await {
                                        Ok(Ok(result)) => {
                                            log_info(&format!("‚úÖ Imagem processada: {} caracteres", result.extracted_content.len()));
                                            (Some(result.extracted_content), result.annotation)
                                        }
                                        Ok(Err(e)) => {
                                            log_error(&format!("‚ùå Erro ao processar imagem: {}", e));
                                            (None, None)
                                        }
                                        Err(_) => {
                                            log_error("‚ùå Timeout ao processar imagem (10s)");
                                            (None, None)
                                        }
                                    }
                                }
                                Ok(Ok(_)) => {
                                    log_error("‚ùå Arquivo de imagem muito grande (>3MB), ignorando");
                                    (None, None)
                                }
                                Ok(Err(e)) => {
                                    log_error(&format!("‚ùå Erro ao baixar imagem: {}", e));
                                    (None, None)
                                }
                                Err(_) => {
                                    log_error("‚ùå Timeout ao baixar imagem (8s)");
                                    (None, None)
                                }
                            }
                        }
                        "pdf" => {
                            log_info("üìÑ Processando PDF com extra√ß√£o + anota√ß√£o");
                            // Timeout e limite para PDF (m√°x 10MB, 15s download, 20s processing)
                            match tokio::time::timeout(
                                std::time::Duration::from_secs(15),
                                ia_service.download_file(media_url, "PDF")
                            ).await {
                                Ok(Ok(pdf_bytes)) if pdf_bytes.len() <= 10_000_000 => {
                                    match tokio::time::timeout(
                                        std::time::Duration::from_secs(20),
                                        ia_service.process_pdf_with_annotation(&pdf_bytes)
                                    ).await {
                                        Ok(Ok(result)) => {
                                            log_info(&format!("‚úÖ PDF processado: {} caracteres", result.extracted_content.len()));
                                            (Some(result.extracted_content), result.annotation)
                                        }
                                        Ok(Err(e)) => {
                                            log_error(&format!("‚ùå Erro ao processar PDF: {}", e));
                                            (None, None)
                                        }
                                        Err(_) => {
                                            log_error("‚ùå Timeout ao processar PDF (20s)");
                                            (None, None)
                                        }
                                    }
                                }
                                Ok(Ok(_)) => {
                                    log_error("‚ùå Arquivo PDF muito grande (>10MB), ignorando");
                                    (None, None)
                                }
                                Ok(Err(e)) => {
                                    log_error(&format!("‚ùå Erro ao baixar PDF: {}", e));
                                    (None, None)
                                }
                                Err(_) => {
                                    log_error("‚ùå Timeout ao baixar PDF (15s)");
                                    (None, None)
                                }
                            }
                        }
                        _ => (None, None)
                    }
                } else {
                    log_error("‚ùå IaService n√£o est√° dispon√≠vel no AppState");
                    (None, None)
                };

                // Atualizar payload com resultado PRIMEIRO
                if let Some(result_text) = final_result {
                    let label = match processing_type {
                        "audio" => "Transcri√ß√£o do √°udio",
                        "image" => "Descri√ß√£o da imagem",
                        "pdf" => "Conte√∫do do PDF",
                        _ => "Descri√ß√£o da m√≠dia",
                    };

                    if !chatguru_payload.texto_mensagem.is_empty() {
                        chatguru_payload.texto_mensagem = format!(
                            "{}\n\n[{}]: {}",
                            chatguru_payload.texto_mensagem,
                            label,
                            result_text
                        );
                    } else {
                        chatguru_payload.texto_mensagem = result_text;
                    }

                    log_info(&format!("üìù Payload enriquecido com {}", label));
                } else {
                    log_warning("‚ö†Ô∏è Nenhum resultado de processamento de m√≠dia dispon√≠vel");
                }

                // ENVIAR ANOTA√á√ÉO IMEDIATAMENTE AO CHATGURU (independente de ser atividade ou n√£o)
                // Enviar DEPOIS de modificar o payload para evitar borrow checker issues
                if let Some(annotation) = annotation_opt {
                    let annotation_preview = if annotation.len() > 100 {
                        format!("{}...", &annotation[..100])
                    } else {
                        annotation.clone()
                    };
                    
                    log_info(&format!(
                        "üì§ ENVIANDO ANOTA√á√ÉO DE M√çDIA - ChatID: {} | Type: {} | Preview: \"{}\"",
                        chat_id.as_deref().unwrap_or("N/A"),
                        processing_type,
                        annotation_preview
                    ));
                    
                    if let Err(e) = send_annotation_to_chatguru(&state, &payload, &annotation).await {
                        log_warning(&format!(
                            "‚ö†Ô∏è FALHA NA ANOTA√á√ÉO DE M√çDIA - ChatID: {} | Error: {}",
                            chat_id.as_deref().unwrap_or("N/A"),
                            e
                        ));
                    } else {
                        log_info(&format!(
                            "‚úÖ ANOTA√á√ÉO DE M√çDIA ENVIADA - ChatID: {} | Size: {} chars",
                            chat_id.as_deref().unwrap_or("N/A"),
                            annotation.len()
                        ));
                    }
                }
            }
        }
    }

    // Extrair force_classification se presente
    let force_classification = envelope.get("force_classification");
// Processar mensagem com tratamento robusto de resposta
match process_message(&state, &payload, force_classification).await {
    Ok(result) => {
        let processing_time = start_time.elapsed().as_millis() as u64;
        
        log_info(&format!(
            "‚úÖ WORKER PROCESSAMENTO CONCLU√çDO - Time: {}ms | Status: success",
            processing_time
        ));
        
        log_request_processed("/worker/process", 200, processing_time);
        
        // Garantir que a resposta √© v√°lida e n√£o est√° vazia
        let response = if result.is_null() {
            json!({
                "status": "processed",
                "processing_time_ms": processing_time,
                "result": "empty_payload"
            })
        } else {
            result
        };
        
        Ok(Json(response))
    }
    Err(e) => {
        let processing_time = start_time.elapsed().as_millis() as u64;
        
        log_error(&format!(
            "‚ùå WORKER ERROR - Time: {}ms | Attempt: {}/{} | Error: {}",
            processing_time, retry_count, MAX_RETRY_ATTEMPTS, e
        ));

        // Classificar erro: recuper√°vel vs n√£o-recuper√°vel
        let is_recoverable = match &e {
            // Erros de API externa (ClickUp, HTTP, Timeout) - recuper√°vel
            AppError::ClickUpApi(_) => retry_count < MAX_RETRY_ATTEMPTS,
            AppError::HttpError(_) => retry_count < MAX_RETRY_ATTEMPTS,
            AppError::Timeout(_) => retry_count < MAX_RETRY_ATTEMPTS,
            AppError::PubSubError(_) => retry_count < MAX_RETRY_ATTEMPTS,

            // Erros de configura√ß√£o/valida√ß√£o - N√ÉO recuper√°vel
            AppError::ConfigError(_) => false,
            AppError::ValidationError(_) => false,
            AppError::JsonError(_) => false,

            // Estrutura n√£o encontrada - N√ÉO recuper√°vel (j√° tratado internamente)
            AppError::StructureNotFound(_) => false,

            // Database error - N√ÉO recuper√°vel (indica problema de configura√ß√£o)
            AppError::DatabaseError(_) => false,

            // Outros erros internos - permitir retry limitado
            AppError::InternalError(_) => retry_count < MAX_RETRY_ATTEMPTS,
        };

        if is_recoverable {
            // Erro recuper√°vel - Pub/Sub vai fazer retry
            log_warning(&format!("‚ö†Ô∏è Erro recuper√°vel, Pub/Sub far√° retry (tentativa {}/{})",
                retry_count, MAX_RETRY_ATTEMPTS));
            Err((
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(json!({
                    "error": e.to_string(),
                    "retry_count": retry_count,
                    "max_retries": MAX_RETRY_ATTEMPTS,
                    "will_retry": true,
                    "processing_time_ms": processing_time
                }))
            ))
        } else {
            // Erro n√£o recuper√°vel - retornar 200 para evitar retry
            log_error(&format!("‚ùå Erro n√£o recuper√°vel ou limite de tentativas atingido, descartando mensagem: {}", e));
            
            // Retornar 200 OK com status de erro para evitar retry infinito
            Ok(Json(json!({
                "status": "failed",
                "error": e.to_string(),
                "retry_count": retry_count,
                "max_retries": MAX_RETRY_ATTEMPTS,
                "reason": "Non-recoverable error or max retries exceeded",
                "processing_time_ms": processing_time,
                "discarded": true
            })))
        }
    }
}

}

/// Processa uma mensagem do ChatGuru
async fn process_message(state: &Arc<AppState>, payload: &WebhookPayload, force_classification: Option<&Value>) -> AppResult<Value> {
    // Filtrar eventos que n√£o devem ser processados
    if let WebhookPayload::EventType(event_payload) = payload {
        if event_payload.event_type == "annotation.added" {
            log_info("‚è≠Ô∏è  Ignorando evento annotation.added (gerado pelo sistema)");
            return Ok(json!({
                "status": "skipped",
                "reason": "annotation.added event"
            }));
        }
    }

    // Extrair dados b√°sicos
    let nome = extract_nome_from_payload(payload);
    let message = extract_message_from_payload(payload);
    let phone = extract_phone_from_payload(payload);
    let chat_id = extract_chat_id_from_payload(payload);

    // CORRE√á√ÉO: Usar char_indices para evitar panic com UTF-8 multi-byte
    let message_preview = if message.chars().count() > 150 {
        let mut char_count = 0;
        let mut byte_end = 0;
        for (byte_idx, _) in message.char_indices() {
            if char_count >= 150 {
                byte_end = byte_idx;
                break;
            }
            char_count += 1;
        }
        if byte_end > 0 {
            format!("{}...", &message[..byte_end])
        } else {
            format!("{}...", message.chars().take(150).collect::<String>())
        }
    } else {
        message.clone()
    };

    log_info(&format!(
        "üí¨ PROCESSANDO MENSAGEM - Sender: {} | ChatID: {} | Phone: {} | Message: \"{}\"",
        if !nome.is_empty() { nome.clone() } else { "Desconhecido".to_string() },
        chat_id.as_deref().unwrap_or("N/A"),
        phone.as_deref().unwrap_or("N/A"),
        message_preview
    ));

    // Verificar se h√° classifica√ß√£o for√ßada (bypass OpenAI)
    let classification = if let Some(forced) = force_classification {
        log_info("üîß Usando classifica√ß√£o for√ßada (bypass OpenAI)");

        use crate::services::OpenAIClassification;
        OpenAIClassification {
            reason: forced.get("description")
                .and_then(|v| v.as_str())
                .unwrap_or("Classifica√ß√£o manual")
                .to_string(),
            is_activity: forced.get("is_task_worthy")
                .and_then(|v| v.as_bool())
                .unwrap_or(true),
            category: forced.get("campanha")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            campanha: forced.get("campanha")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            description: forced.get("description")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            space_name: forced.get("space_name")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            folder_name: forced.get("folder_name")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            list_name: forced.get("list_name")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            info_1: forced.get("info_1")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            info_2: forced.get("info_2")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
            tipo_atividade: None,
            sub_categoria: None,
            subtasks: vec![],
            status_back_office: None,
        }
    } else {
        // Classificar com IaService (OpenAI)
        log_info(&format!(
            "ü§ñ INICIANDO CLASSIFICA√á√ÉO IA - ChatID: {} | Sender: {}",
            chat_id.as_deref().unwrap_or("N/A"),
            nome
        ));
        
        let ia_service = state.ia_service.as_ref()
            .ok_or_else(|| AppError::InternalError("IaService n√£o dispon√≠vel no AppState".to_string()))?;

        // Carregar configura√ß√£o de prompt
        use chatguru_clickup_middleware::services::prompts::AiPromptConfig;
        let prompt_config = AiPromptConfig::load_default().await
            .map_err(|e| AppError::InternalError(format!("Failed to load prompt config: {}", e)))?;

        // Montar contexto
        let context = format!(
            "Campanha: WhatsApp\nOrigem: whatsapp\nNome: {}\nMensagem: {}\nTelefone: {}",
            nome, message, phone.as_deref().unwrap_or("N/A")
        );

        // Gerar prompt usando a configura√ß√£o
        let formatted_prompt = prompt_config.generate_prompt(&context);

        log_info(&format!(
            "üìù PROMPT GERADO - ChatID: {} | Context size: {} chars | Prompt size: {} chars",
            chat_id.as_deref().unwrap_or("N/A"),
            context.len(),
            formatted_prompt.len()
        ));

        // Classificar com IA com timeout (m√°x 8 segundos)
        match tokio::time::timeout(
            std::time::Duration::from_secs(8),
            ia_service.classify_activity(&formatted_prompt)
        ).await {
            Ok(Ok(c)) => {
                log_info(&format!(
                    "‚úÖ CLASSIFICA√á√ÉO IA CONCLU√çDA - ChatID: {} | Is_activity: {} | Category: {} | Confidence: {}",
                    chat_id.as_deref().unwrap_or("N/A"),
                    c.is_activity,
                    c.category.as_deref().unwrap_or("N/A"),
                    "N/A" // Confidence n√£o est√° dispon√≠vel na struct atual
                ));
                c
            },
            Ok(Err(e)) => {
                log_error(&format!(
                    "‚ùå FALHA NA CLASSIFICA√á√ÉO IA - ChatID: {} | Error: {}",
                    chat_id.as_deref().unwrap_or("N/A"),
                    e
                ));
                return Err(AppError::InternalError(format!("IA classification failed: {}", e)));
            },
            Err(_) => {
                log_error(&format!(
                    "‚ùå TIMEOUT NA CLASSIFICA√á√ÉO IA - ChatID: {} | Exceeded 8s",
                    chat_id.as_deref().unwrap_or("N/A")
                ));
                return Err(AppError::Timeout("IA classification timeout".to_string()));
            }
        }
    };

    let is_activity = classification.is_activity;

    if is_activity {
        log_info(&format!("‚úÖ Atividade identificada: {}", classification.reason));

        // NOVA L√ìGICA COM SMARTFOLDERFINDER:
        // 1. Extrai Info_2 (nome do cliente)
        // 2. Busca folder via API do ClickUp com fuzzy matching
        // 3. Fallback: busca em tarefas anteriores pelo campo "Cliente Solicitante"
        // 4. Retorna folder_id + list_id do m√™s atual

        let client_name = extract_info_2_from_payload(payload)
            .unwrap_or_else(|| extract_nome_from_payload(payload));

        log_info(&format!("üîç SmartFolderFinder: Buscando folder para Info_2='{}'", client_name));
        log_info(&format!("üìã Debug campos: Info_2 (cliente)={:?}, Info_1 (empresa)={:?}, responsavel_nome (atendente)={:?}",
            extract_info_2_from_payload(payload),
            extract_info_1_from_payload(payload),
            extract_responsavel_nome_from_payload(payload)
        ));

        // Inicializar SmartFolderFinder
        let api_token = std::env::var("CLICKUP_API_TOKEN")
            .or_else(|_| std::env::var("clickup_api_token"))
            .or_else(|_| std::env::var("CLICKUP_TOKEN"))
            .map_err(|_| AppError::ConfigError("CLICKUP_API_TOKEN n√£o configurado".to_string()))?;

        let workspace_id = std::env::var("CLICKUP_WORKSPACE_ID")
            .or_else(|_| std::env::var("CLICKUP_TEAM_ID")) // Fallback para compatibilidade
            .unwrap_or_else(|_| "9013037641".to_string()); // Workspace ID da Nordja

        // Clonar para uso posterior no assignee_finder
        let folder_api_token = api_token.clone();
        let folder_workspace_id = workspace_id.clone();

        let mut finder = SmartFolderFinder::from_token(folder_api_token, folder_workspace_id)
            .map_err(|e| AppError::ClickUpApi(format!("Failed to create SmartFolderFinder: {}", e)))?;

        // Buscar folder de forma inteligente
        let folder_result = match finder.find_folder_for_client(&client_name).await {
            Ok(Some(result)) => {
                log_info(&format!(
                    "‚úÖ Folder encontrado: {} (id: {}, m√©todo: {:?}, confian√ßa: {:.2})",
                    result.folder_name,
                    result.folder_id,
                    result.search_method,
                    result.confidence
                ));

                if let (Some(list_id), Some(list_name)) = (result.list_id.clone(), result.list_name.clone()) {
                    log_info(&format!("üìã Lista do m√™s: {} (id: {})", list_name, list_id));
                }

                Some(result)
            }
            Ok(None) => {
                log_warning(&format!(
                    "‚ö†Ô∏è Folder n√£o encontrado para '{}', usando fallback do ClickUpService",
                    client_name
                ));
                None
            }
            Err(e) => {
                log_error(&format!("‚ùå Erro ao buscar folder: {}, usando fallback", e));
                None
            }
        };

        // Buscar assignee (respons√°vel) se dispon√≠vel
        let assignee_result = if let Some(ref responsavel) = extract_responsavel_nome_from_payload(payload) {
            log_info(&format!("üë§ Buscando assignee para responsavel_nome: '{}'", responsavel));

            // Clonar para evitar move
            let assignee_api_token = api_token.clone();
            let assignee_workspace_id = workspace_id.clone();

            let mut assignee_finder = SmartAssigneeFinder::from_token(assignee_api_token, assignee_workspace_id)
                .map_err(|e| AppError::ClickUpApi(format!("Failed to create SmartAssigneeFinder: {}", e)))?;

            match assignee_finder.find_assignee_by_name(responsavel).await {
                Ok(Some(result)) => {
                    log_info(&format!(
                        "‚úÖ Assignee encontrado: {} (user_id: {}, m√©todo: {:?}, confian√ßa: {:.2})",
                        result.username,
                        result.user_id,
                        result.search_method,
                        result.confidence
                    ));
                    Some(result)
                }
                Ok(None) => {
                    log_warning(&format!(
                        "‚ö†Ô∏è Assignee n√£o encontrado para '{}', tarefa ser√° criada sem respons√°vel",
                        responsavel
                    ));

                    None
                }
                Err(e) => {
                    log_error(&format!("‚ùå Erro ao buscar assignee: {}, continuando sem respons√°vel", e));
                    None
                }
            }
        } else {
            log_info("‚ÑπÔ∏è Sem responsavel_nome no payload, tarefa ser√° criada sem assignee");

            None
        };

        // Criar task_data
        let mut task_data = payload.to_clickup_task_data_with_ai(Some(&classification)).await;

        // Adicionar assignee ao task_data se encontrado
        if let Some(assignee_info) = assignee_result {
            if let Some(obj) = task_data.as_object_mut() {
                obj.insert("assignees".to_string(), serde_json::json!(vec![assignee_info.user_id]));
                log_info(&format!("‚úÖ Assignee adicionado ao task_data: {}", assignee_info.username));
            }
        }

        // Processar resultado do SmartFolderFinder
        let task_result = if let Some(folder_info) = folder_result {
            if let Some(list_id) = folder_info.list_id {
                // Garantir que "Cliente Solicitante" corresponda ao folder encontrado
                log_info(&format!(
                    "üìù Configurando 'Cliente Solicitante' para: '{}'",
                    folder_info.folder_name
                ));

                let custom_field_manager = CustomFieldManager::from_token(api_token.clone())
                    .map_err(|e| AppError::ClickUpApi(format!("Failed to create CustomFieldManager: {}", e)))?;

                match custom_field_manager
                    .ensure_client_solicitante_option(&list_id, &folder_info.folder_name)
                    .await
                {
                    Ok(client_field) => {
                        log_info("‚úÖ Campo 'Cliente Solicitante' configurado");

                        // Adicionar/substituir o campo custom no task_data
                        if let Some(obj) = task_data.as_object_mut() {
                            // Buscar custom_fields existentes ou criar array vazio
                            let custom_fields = obj
                                .entry("custom_fields")
                                .or_insert_with(|| serde_json::json!([]));

                            if let Some(fields_array) = custom_fields.as_array_mut() {
                                // Remover campo "Cliente Solicitante" se j√° existir
                                fields_array.retain(|f| {
                                    f.get("id")
                                        .and_then(|id| id.as_str())
                                        != Some("0ed63eec-1c50-4190-91c1-59b4b17557f6")
                                });

                                // Adicionar novo valor
                                fields_array.push(client_field);

                                log_info(&format!(
                                    "‚úÖ 'Cliente Solicitante' sincronizado com folder: '{}'",
                                    folder_info.folder_name
                                ));
                            }
                        }
                    }
                    Err(e) => {
                        log_warning(&format!(
                            "‚ö†Ô∏è Erro ao configurar 'Cliente Solicitante': {}, continuando sem o campo",
                            e
                        ));
                    }
                }
                log_info(&format!(
                    "üéØ Criando tarefa diretamente na lista: {} (folder: {})",
                    list_id, folder_info.folder_id
                ));

                // Adicionar list_id ao task_data
                if let Some(obj) = task_data.as_object_mut() {
                    obj.insert("list_id".to_string(), serde_json::json!(list_id));
                }

                // Converter Value para Task tipada
                let task: clickup::Task = serde_json::from_value(task_data)?;

                // Deduplica√ß√£o: checar se j√° existe tarefa com o mesmo t√≠tulo antes de criar
                let existing = state.clickup.find_existing_task_in_list(
                    Some(&list_id),
                    &task.name
                ).await;

                match existing {
                    Ok(Some(_task_found)) => {
                        log_info(&format!("‚ùó Tarefa j√° existe no ClickUp com o mesmo t√≠tulo: '{}'. N√£o ser√° criada nova task.", &task.name));
                        return Ok(serde_json::json!({
                            "status": "duplicate",
                            "message": "Tarefa j√° existente, n√£o criada novamente",
                            "task_title": &task.name
                        }));
                    }
                    Ok(None) => {
                        // S√≥ cria a task se n√£o houver duplicata
                        match state.clickup.create_task(&task).await {
                            Ok(created_task) => {
                                log_info(&format!("‚úÖ Tarefa criada via SmartFolderFinder: {}", created_task.id.as_ref().unwrap_or(&"?".to_string())));
                                serde_json::to_value(&created_task)
                                    .unwrap_or_else(|_| serde_json::json!({"id": created_task.id}))
                            }
                            Err(e) => {
                                log_error(&format!("‚ùå Erro ao criar tarefa: {}", e));
                                return Err(AppError::ClickUpApi(e.to_string()));
                            }
                        }
                    }
                    Err(e) => {
                        log_error(&format!("‚ùå Erro ao buscar duplicata no ClickUp: {}", e));
                        return Err(AppError::ClickUpApi(e.to_string()));
                    }
                }
            } else {
                // Tem folder mas n√£o tem lista do m√™s - encaminhar para App Engine
                log_warning(&format!(
                    "‚ö†Ô∏è Folder '{}' encontrado mas sem lista do m√™s, encaminhando para App Engine",
                    folder_info.folder_name
                ));

                // Enviar anota√ß√£o de warning ao ChatGuru
                let warning_annotation = format!(
                    "‚ö†Ô∏è **LISTA DO M√äS N√ÉO ENCONTRADA**\n\n\
                    üìÇ Pasta: '{}'\n\
                    üìã Lista mensal n√£o criada ainda\n\n\
                    ‚ÑπÔ∏è A tarefa ser√° processada pelo sistema legado (App Engine).\n\n\
                    ‚úÖ **A√ß√£o necess√°ria**: Crie a lista do m√™s atual na pasta '{}' no ClickUp.",
                    folder_info.folder_name,
                    folder_info.folder_name
                );

                if let Err(e) = send_annotation_to_chatguru(&state, &payload, &warning_annotation).await {
                    log_warning(&format!("‚ö†Ô∏è N√£o foi poss√≠vel enviar anota√ß√£o de warning: {}", e));
                }

                // Enviar payload original para o App Engine
                forward_to_app_engine(&payload).await?;

                log_info("‚úÖ Payload encaminhado para App Engine com sucesso - Processamento encerrado");

                // Retornar resposta de sucesso sem criar task no ClickUp
                return Ok(json!({
                    "status": "forwarded_to_app_engine",
                    "message": "Folder encontrado mas sem lista do m√™s, payload encaminhado para App Engine",
                    "folder_name": folder_info.folder_name,
                    "app_engine_url": "https://buzzlightear.rj.r.appspot.com/webhook"
                }));
            }
        } else {
            // N√£o encontrou folder, encaminhar para App Engine
            log_warning(&format!("‚ö†Ô∏è Folder n√£o encontrado para '{}'", client_name));

            log_info("‚ÑπÔ∏è Anota√ß√£o de fallback desabilitada ‚Äî apenas encaminhando para o App Engine");

            // Enviar payload original para o App Engine e encerrar processamento
            forward_to_app_engine(&payload).await?;

            log_info("‚úÖ Payload encaminhado para App Engine com sucesso - Processamento encerrado");

            // Retornar resposta de sucesso sem criar task no ClickUp
            // O App Engine ser√° respons√°vel por todo o processamento daqui em diante
            return Ok(json!({
                "status": "forwarded_to_app_engine",
                "message": "Cliente n√£o encontrado no Cloud Run, payload encaminhado para App Engine",
                "client_name": client_name,
                "app_engine_url": "https://buzzlightear.rj.r.appspot.com/webhook"
            }));
        };

        // Montar anota√ß√£o com informa√ß√µes da task
        let task_id = task_result.get("id").and_then(|v| v.as_str()).unwrap_or("N/A");
        let task_url = task_result.get("url").and_then(|v| v.as_str()).unwrap_or("");

        // CORRE√á√ÉO: N√£o incluir descri√ß√£o de m√≠dia na anota√ß√£o da tarefa se j√° foi enviada separadamente
        // A descri√ß√£o do PDF/√°udio/imagem j√° foi enviada como anota√ß√£o de m√≠dia nas linhas 402-429
        // Incluir aqui seria duplica√ß√£o desnecess√°ria
        let media_description_section = String::new();

        let annotation = format!(
            "‚úÖ Tarefa criada no ClickUp\n\nüìã Descri√ß√£o: {}\nüè∑Ô∏è Categoria: {}\nüìÇ Subcategoria: {}\n‚≠ê Prioridade: {} estrela(s)\nüîó Link: {}{}",
            classification.reason,
            classification.campanha.as_deref().unwrap_or("N/A"),
            classification.sub_categoria.as_deref().unwrap_or("N/A"),
            // Extrair prioridade da task_result se dispon√≠vel
            task_result.get("priority")
                .and_then(|p| p.get("orderindex"))
                .and_then(|o| o.as_str())
                .map(|s| match s {
                    "1" => "4",
                    "2" => "3",
                    "3" => "2",
                    _ => "1"
                })
                .unwrap_or("N/A"),
            task_url,
            media_description_section
        );

        // Enviar anota√ß√£o ao ChatGuru
        if let Err(e) = send_annotation_to_chatguru(state, payload, &annotation).await {
            log_warning(&format!("‚ö†Ô∏è  Falha ao enviar anota√ß√£o ao ChatGuru: {}", e));
            // N√£o falhar o processamento se anota√ß√£o falhar
        }

        Ok(json!({
            "status": "processed",
            "is_activity": true,
            "task_id": task_id,
            "annotation": annotation
        }))
    } else {
        log_info(&format!("‚ùå N√£o √© atividade: {}", classification.reason));

        let annotation = format!("N√£o √© uma tarefa: {}", classification.reason);

        // Apenas enviar anota√ß√£o
        if let Err(e) = send_annotation_to_chatguru(state, payload, &annotation).await {
            log_warning(&format!("‚ö†Ô∏è  Falha ao enviar anota√ß√£o ao ChatGuru: {}", e));
        }

        Ok(json!({
            "status": "processed",
            "is_activity": false,
            "annotation": annotation
        }))
    }
}

/// Envia anota√ß√£o de volta ao ChatGuru
async fn send_annotation_to_chatguru(
    state: &Arc<AppState>,
    payload: &WebhookPayload,
    annotation: &str,
) -> AppResult<()> {
    let api_token = state.settings.chatguru.api_token.clone()
        .unwrap_or_else(|| "default_token".to_string());
    let api_endpoint = state.settings.chatguru.api_endpoint.clone()
        .unwrap_or_else(|| "https://s15.chatguru.app/api/v1".to_string());
    let account_id = state.settings.chatguru.account_id.clone()
        .unwrap_or_else(|| "default_account".to_string());

    let chatguru_service = ChatGuruClient::new(api_token, api_endpoint.clone(), account_id);

    let chat_id = extract_chat_id_from_payload(payload);
    let phone = extract_phone_from_payload(payload);

    if let Some(chat_id) = chat_id {
        let phone_str = phone.as_deref().unwrap_or("");
        
        // Log detalhado antes de enviar
        log_info(&format!(
            "üì° ENVIANDO PARA CHATGURU - ChatID: {} | Phone: {} | Endpoint: {} | Size: {} chars",
            chat_id,
            phone_str,
            api_endpoint,
            annotation.len()
        ));
        
        chatguru_service.add_annotation(&chat_id, phone_str, annotation).await?;
        
        log_info(&format!(
            "‚úÖ ANOTA√á√ÉO CONFIRMADA NO CHATGURU - ChatID: {} | Success",
            chat_id
        ));
    } else {
        log_warning("‚ö†Ô∏è CHAT_ID N√ÉO ENCONTRADO - N√£o foi poss√≠vel enviar anota√ß√£o ao ChatGuru");
    }

    Ok(())
}

// ============================================================================
// Fun√ß√µes auxiliares de extra√ß√£o de dados
// ============================================================================

fn extract_nome_from_payload(payload: &WebhookPayload) -> String {
    match payload {
        WebhookPayload::ChatGuru(p) => {
            if p.nome.is_empty() {
                "Desconhecido".to_string()
            } else {
                p.nome.clone()
            }
        },
        WebhookPayload::EventType(p) => p.data.lead_name.clone().unwrap_or_else(|| "Desconhecido".to_string()),
        WebhookPayload::Generic(p) => p.nome.clone().unwrap_or_else(|| "Desconhecido".to_string()),
    }
}

fn extract_message_from_payload(payload: &WebhookPayload) -> String {
    match payload {
        WebhookPayload::ChatGuru(p) => p.texto_mensagem.clone(),
        WebhookPayload::EventType(p) => p.data.annotation.clone().unwrap_or_default(),
        WebhookPayload::Generic(p) => p.mensagem.clone().unwrap_or_default(),
    }
}

fn extract_phone_from_payload(payload: &WebhookPayload) -> Option<String> {
    match payload {
        WebhookPayload::ChatGuru(p) => Some(p.celular.clone()),
        WebhookPayload::EventType(p) => p.data.phone.clone(),
        WebhookPayload::Generic(_) => None,
    }
}

fn extract_chat_id_from_payload(payload: &WebhookPayload) -> Option<String> {
    match payload {
        WebhookPayload::ChatGuru(p) => p.chat_id.clone(),
        WebhookPayload::EventType(_) => None,  // EventType n√£o tem chat_id direto
        WebhookPayload::Generic(_) => None,
    }
}

/// Extrai Info_1 (EMPRESA CLIENTE - apenas para campo personalizado) dos campos personalizados
/// Info_1 = dados.campos_personalizados.Info_1
/// Usado APENAS para preencher o campo personalizado "Conta cliente"
/// N√ÉO √© usado para determinar Space ou Folder
fn extract_info_1_from_payload(payload: &WebhookPayload) -> Option<String> {
    match payload {
        WebhookPayload::ChatGuru(p) => {
            p.campos_personalizados.get("Info_1")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string())
        },
        _ => None,
    }
}

/// Extrai Info_2 (NOME DO SOLICITANTE - campo personalizado) dos campos personalizados
/// Info_2 = dados.campos_personalizados.Info_2
/// Usado para preencher o campo personalizado "Solicitante" (n√£o determina estrutura)
/// Exemplo: "Jo√£o Silva" ‚Üí Campo personalizado "Solicitante"
fn extract_info_2_from_payload(payload: &WebhookPayload) -> Option<String> {
    match payload {
        WebhookPayload::ChatGuru(p) => {
            p.campos_personalizados.get("Info_2")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string())
        },
        _ => None,
    }
}

/// Extrai responsavel_nome (ATENDENTE - determina SPACE) do payload do ChatGuru
/// responsavel_nome = dados.responsavel_nome
/// Usado para determinar qual Space usar (Anne Souza, Gabriel Moreno, William Duarte, etc.)
/// Exemplo: "anne" ‚Üí Space "Anne Souza"
fn extract_responsavel_nome_from_payload(payload: &WebhookPayload) -> Option<String> {
    match payload {
        WebhookPayload::ChatGuru(p) => {
            p.responsavel_nome.clone()
        },
        _ => None,
    }
}

// ============================================================================
// FUN√á√ïES OBSOLETAS - MIGRADAS PARA src/models/payload.rs
// ============================================================================
//
// NOVA IMPLEMENTA√á√ÉO:
// - Subcategorias e Estrelas: src/models/payload.rs:333-362 (fun√ß√£o chatguru_to_clickup_with_ai)
// - Usa configura√ß√£o YAML: config/ai_prompt.yaml
// - Mapeamento via AiPromptConfig::load_default()
// - Log de estrelas: payload.rs:348-353
//
// FLUXO ATUAL:
// 1. OpenAI Service ‚Üí classifica mensagem (category, sub_categoria)
// 2. ClickUp Service ‚Üí chama payload.to_clickup_task_data_with_ai()
// 3. Payload.rs ‚Üí mapeia subcategorias/estrelas via YAML
// 4. ClickUp Service ‚Üí envia para API via create_task_from_json()
//
// As fun√ß√µes abaixo foram mantidas para refer√™ncia hist√≥rica
// ============================================================================

/// FUN√á√ÉO OBSOLETA - N√ÉO MAIS UTILIZADA
///
/// NOVA IMPLEMENTA√á√ÉO: src/models/payload.rs:240-441 (custom_fields)
/// A prepara√ß√£o de campos personalizados agora usa configura√ß√£o YAML
/// e est√° integrada diretamente na convers√£o do payload
#[allow(dead_code)]
async fn prepare_custom_fields(
    payload: &WebhookPayload,
    classification: &chatguru_clickup_middleware::services::OpenAIClassification,
    _nome: &str,
) -> Vec<Value> {
    let mut custom_fields = Vec::new();

    // IDs reais dos campos personalizados (do script categorize_tasks.js)

    // 1. Campo: Categoria* (dropdown) - ID real do ClickUp
    if let Some(category) = &classification.category {
        custom_fields.push(json!({
            "id": "eac5bbd3-4ff6-41ac-aa93-0a13a5a2c75a", // ID real do campo Categoria*
            "value": category // Categoria determinada pela classifica√ß√£o IA
        }));
    }

    // 2. Campo: SubCategoria (dropdown) - ID real do ClickUp
    if let Some(subcategory) = determine_subcategoria(classification) {
        custom_fields.push(json!({
            "id": "5333c095-eb40-4a5a-b0c2-76bfba4b1094", // ID real do campo SubCategoria
            "value": subcategory
        }));
    }

    // 3. Campo: Estrelas (rating) - ID real do ClickUp
    let stars = determine_estrelas(classification, payload).await;
    custom_fields.push(json!({
        "id": "83afcb8c-2866-498f-9c62-8ea9666b104b", // ID real do campo Estrelas
        "value": stars // Valor num√©rico de 1 a 4
    }));

    custom_fields
}

/// FUN√á√ÉO OBSOLETA - N√ÉO MAIS UTILIZADA
///
/// NOVA IMPLEMENTA√á√ÉO:
/// - OpenAI Service j√° retorna `sub_categoria` classificada
/// - Mapeamento de IDs via config/ai_prompt.yaml
/// - Processamento em src/models/payload.rs:333-362
///
/// A determina√ß√£o de subcategorias agora √© feita pela IA e mapeada via YAML,
/// n√£o mais por palavra-chave hardcoded
#[allow(dead_code)]
fn determine_subcategoria(classification: &chatguru_clickup_middleware::services::OpenAIClassification) -> Option<String> {
    // An√°lise de palavras-chave da mensagem/descri√ß√£o para determinar subcategoria
    let message_text = classification.reason.to_lowercase();
    
    // MAPEAMENTO EXATO do categorize_tasks.js - KEYWORD_MAPPING
    // Log√≠stica
    if message_text.contains("motoboy") || message_text.contains("entrega") || message_text.contains("retirada") {
        Some("Corrida de motoboy".to_string())
    } else if message_text.contains("sedex") || message_text.contains("correio") {
        Some("Motoboy + Correios e envios internacionais".to_string())
    } else if message_text.contains("lalamove") {
        Some("Lalamove".to_string())
    } else if message_text.contains("uber") || message_text.contains("99") {
        Some("Transporte Urbano (Uber/99)".to_string())
    } else if message_text.contains("taxista") {
        Some("Corridas com Taxistas".to_string())
    }
    // Plano de Sa√∫de
    else if message_text.contains("reembolso") || message_text.contains("bradesco sa√∫de") || message_text.contains("plano de sa√∫de") {
        Some("Reembolso M√©dico".to_string())
    }
    // Compras
    else if message_text.contains("mercado") {
        Some("Mercados".to_string())
    } else if message_text.contains("farm√°cia") {
        Some("Farm√°cia".to_string())
    } else if message_text.contains("presente") {
        Some("Presentes".to_string())
    } else if message_text.contains("shopper") {
        Some("Shopper".to_string())
    } else if message_text.contains("papelaria") {
        Some("Papelaria".to_string())
    } else if message_text.contains("petshop") {
        Some("Petshop".to_string())
    } else if message_text.contains("ingresso") {
        Some("Ingressos".to_string())
    }
    // Assuntos Pessoais
    else if message_text.contains("troca") {
        Some("Troca de titularidade".to_string())
    } else if message_text.contains("internet") {
        Some("Internet e TV por Assinatura".to_string())
    } else if message_text.contains("telefone") {
        Some("Telefone".to_string())
    } else if message_text.contains("conserto") {
        Some("Consertos na Casa".to_string())
    } else if message_text.contains("assist√™ncia") {
        Some("Assist√™ncia T√©cnica".to_string())
    }
    // Financeiro
    else if message_text.contains("pagamento") {
        Some("Rotina de Pagamentos".to_string())
    } else if message_text.contains("boleto") {
        Some("Emiss√£o de boletos".to_string())
    } else if message_text.contains("nota fiscal") {
        Some("Emiss√£o de NF".to_string())
    }
    // Viagens
    else if message_text.contains("passagem") {
        Some("Passagens A√©reas".to_string())
    } else if message_text.contains("hospedagem") || message_text.contains("hotel") {
        Some("Hospedagens".to_string())
    } else if message_text.contains("check in") {
        Some("Checkins (Early/Late)".to_string())
    } else if message_text.contains("bagagem") {
        Some("Extravio de Bagagens".to_string())
    }
    // Agendamentos
    else if message_text.contains("consulta") {
        Some("Consultas".to_string())
    } else if message_text.contains("exame") {
        Some("Exames".to_string())
    } else if message_text.contains("vacina") {
        Some("Vacinas".to_string())
    } else if message_text.contains("manicure") {
        Some("Manicure".to_string())
    } else if message_text.contains("cabeleireiro") {
        Some("Cabeleleiro".to_string())
    }
    // Lazer
    else if message_text.contains("restaurante") || message_text.contains("reserva") {
        Some("Reserva de restaurantes/bares".to_string())
    } else if message_text.contains("festa") {
        Some("Planejamento de festas".to_string())
    }
    // Documentos
    else if message_text.contains("passaporte") {
        Some("Passaporte".to_string())
    } else if message_text.contains("cnh") {
        Some("CNH".to_string())
    } else if message_text.contains("cidadania") {
        Some("Cidadanias".to_string())
    } else if message_text.contains("visto") {
        Some("Vistos e Vistos Eletr√¥nicos".to_string())
    } else if message_text.contains("certid√£o") {
        Some("Certid√µes".to_string())
    } else if message_text.contains("contrato") {
        Some("Contratos/Procura√ß√µes".to_string())
    }
    // Fallback: usar categoria padr√£o
    else if let Some(category) = &classification.category {
        match category.as_str() {
            "Log√≠stica" => Some("Corrida de motoboy".to_string()),
            "Plano de Sa√∫de" => Some("Reembolso M√©dico".to_string()),
            "Compras" => Some("Mercados".to_string()),
            "Agendamentos" => Some("Consultas".to_string()),
            "Lazer" => Some("Reserva de restaurantes/bares".to_string()),
            "Viagens" => Some("Passagens A√©reas".to_string()),
            "Financeiro" => Some("Rotina de Pagamentos".to_string()),
            "Documentos" => Some("Passaporte".to_string()),
            "Assuntos Pessoais" => Some("Telefone".to_string()),
            _ => Some("Consultas".to_string()) // Padr√£o geral
        }
    } else {
        None
    }
}

/// FUN√á√ÉO OBSOLETA - N√ÉO MAIS UTILIZADA
///
/// NOVA IMPLEMENTA√á√ÉO:
/// - Mapeamento de estrelas via config/ai_prompt.yaml
/// - Processamento em src/models/payload.rs:348-353
/// - Log autom√°tico: "‚ú® Tarefa classificada: 'categoria' > 'subcategoria' (X estrela(s))"
///
/// As estrelas agora s√£o determinadas pela configura√ß√£o YAML baseada na
/// subcategoria retornada pela classifica√ß√£o IA
#[allow(dead_code)]
async fn determine_estrelas(
    classification: &chatguru_clickup_middleware::services::OpenAIClassification,
    _payload: &WebhookPayload,
) -> i32 {
    use chatguru_clickup_middleware::services::prompts::AiPromptConfig;

    // Carregar configura√ß√£o do YAML
    let config = match AiPromptConfig::load_default().await {
        Ok(cfg) => cfg,
        Err(e) => {
            log_warning(&format!("Failed to load AI prompt config for stars: {}, using fallback", e));
            return 1; // Fallback direto
        }
    };

    // Usar categoria e subcategoria retornadas pelo OpenAI para buscar as estrelas
    if let (Some(category), Some(sub_categoria)) = (&classification.category, &classification.sub_categoria) {
        if let Some(stars) = config.get_subcategory_stars(category, sub_categoria) {
            log_info(&format!("‚≠ê Estrelas determinadas via YAML: {} ({}‚Üí{})",
                stars, category, sub_categoria));
            return stars as i32;
        } else {
            log_warning(&format!("Subcategoria '{}' n√£o encontrada no YAML para categoria '{}', usando fallback",
                sub_categoria, category));
        }
    }

    // Fallback: 1 estrela padr√£o
    log_info("Using fallback: 1 star");
    1
}

// ============================================================================
// App Engine Fallback
// ============================================================================

/// Encaminha payload original do ChatGuru para o App Engine (fallback)
///
/// Usado quando o SmartFolderFinder n√£o consegue encontrar o folder do cliente.
/// O App Engine processa o payload com sua pr√≥pria l√≥gica e pode ter outros
/// folders/listas cadastrados.
async fn forward_to_app_engine(payload: &WebhookPayload) -> AppResult<()> {
    const APP_ENGINE_URL: &str = "https://buzzlightear.rj.r.appspot.com/webhook";

    log_info("üîÑ Encaminhando payload para App Engine...");

    // Serializar o payload completo
    let payload_json = serde_json::to_value(payload)
        .map_err(|e| AppError::InternalError(format!("Failed to serialize payload: {}", e)))?;

    // Fazer POST para o App Engine
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(30))
        .build()
        .unwrap_or_else(|_| reqwest::Client::new());

    let response = client
        .post(APP_ENGINE_URL)
        .header("Content-Type", "application/json")
        .header("X-Forwarded-From", "cloud-run-middleware")
        .json(&payload_json)
        .send()
        .await
        .map_err(|e| AppError::InternalError(format!("Failed to forward to App Engine: {}", e)))?;

    let status = response.status();

    if status.is_success() {
        let response_body = response.text().await.unwrap_or_default();
        log_info(&format!("‚úÖ App Engine response ({}): {}", status, response_body));
        Ok(())
    } else {
        let error_body = response.text().await.unwrap_or_default();
        log_error(&format!("‚ùå App Engine returned error ({}): {}", status, error_body));
        Err(AppError::InternalError(format!(
            "App Engine returned status {}: {}",
            status, error_body
        )))
    }
}